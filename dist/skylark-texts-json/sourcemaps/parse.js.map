{"version":3,"sources":["parse.js"],"names":["define","json","state","stack","container","key","value","escapes","\\","\"","/","t","n","r","f","b","string","go","firstokey","okey","ovalue","firstavalue","avalue","number","action","{","push","}","pop","ocomma","[","]","acomma",":","colon","Object","hasOwnProperty","call","SyntaxError",",","true","false","null","parse","source","reviver","result","text","tx","exec","replace","ignore","c","String","fromCharCode","parseInt","slice","length","e","test","walk","holder","k","v","val","prototype","undefined",""],"mappings":"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","file":"../parse.js","sourcesContent":["define([\r\n\t\"./json\"\r\n],function(json){\r\n    \"use strict\";\r\n\r\n    \"use strict\";\r\n\r\n// This function creates a JSON parse function that uses a state machine rather\r\n// than the dangerous eval function to parse a JSON text.\r\n\r\n    var state;      // The state of the parser, one of\r\n                    // 'go'         The starting state\r\n                    // 'ok'         The final, accepting state\r\n                    // 'firstokey'  Ready for the first key of the object or\r\n                    //              the closing of an empty object\r\n                    // 'okey'       Ready for the next key of the object\r\n                    // 'colon'      Ready for the colon\r\n                    // 'ovalue'     Ready for the value half of a key/value pair\r\n                    // 'ocomma'     Ready for a comma or closing }\r\n                    // 'firstavalue' Ready for the first value of an array or\r\n                    //              an empty array\r\n                    // 'avalue'     Ready for the next value of an array\r\n                    // 'acomma'     Ready for a comma or closing ]\r\n    var stack;      // The stack, for controlling nesting.\r\n    var container;  // The current container object or array\r\n    var key;        // The current key\r\n    var value;      // The current value\r\n    var escapes = { // Escapement translation table\r\n        \"\\\\\": \"\\\\\",\r\n        \"\\\"\": \"\\\"\",\r\n        \"/\": \"/\",\r\n        \"t\": \"\\t\",\r\n        \"n\": \"\\n\",\r\n        \"r\": \"\\r\",\r\n        \"f\": \"\\f\",\r\n        \"b\": \"\\b\"\r\n    };\r\n    var string = {   // The actions for string tokens\r\n        go: function () {\r\n            state = \"ok\";\r\n        },\r\n        firstokey: function () {\r\n            key = value;\r\n            state = \"colon\";\r\n        },\r\n        okey: function () {\r\n            key = value;\r\n            state = \"colon\";\r\n        },\r\n        ovalue: function () {\r\n            state = \"ocomma\";\r\n        },\r\n        firstavalue: function () {\r\n            state = \"acomma\";\r\n        },\r\n        avalue: function () {\r\n            state = \"acomma\";\r\n        }\r\n    };\r\n    var number = {   // The actions for number tokens\r\n        go: function () {\r\n            state = \"ok\";\r\n        },\r\n        ovalue: function () {\r\n            state = \"ocomma\";\r\n        },\r\n        firstavalue: function () {\r\n            state = \"acomma\";\r\n        },\r\n        avalue: function () {\r\n            state = \"acomma\";\r\n        }\r\n    };\r\n    var action = {\r\n\r\n// The action table describes the behavior of the machine. It contains an\r\n// object for each token. Each object contains a method that is called when\r\n// a token is matched in a state. An object will lack a method for illegal\r\n// states.\r\n\r\n        \"{\": {\r\n            go: function () {\r\n                stack.push({state: \"ok\"});\r\n                container = {};\r\n                state = \"firstokey\";\r\n            },\r\n            ovalue: function () {\r\n                stack.push({container: container, state: \"ocomma\", key: key});\r\n                container = {};\r\n                state = \"firstokey\";\r\n            },\r\n            firstavalue: function () {\r\n                stack.push({container: container, state: \"acomma\"});\r\n                container = {};\r\n                state = \"firstokey\";\r\n            },\r\n            avalue: function () {\r\n                stack.push({container: container, state: \"acomma\"});\r\n                container = {};\r\n                state = \"firstokey\";\r\n            }\r\n        },\r\n        \"}\": {\r\n            firstokey: function () {\r\n                var pop = stack.pop();\r\n                value = container;\r\n                container = pop.container;\r\n                key = pop.key;\r\n                state = pop.state;\r\n            },\r\n            ocomma: function () {\r\n                var pop = stack.pop();\r\n                container[key] = value;\r\n                value = container;\r\n                container = pop.container;\r\n                key = pop.key;\r\n                state = pop.state;\r\n            }\r\n        },\r\n        \"[\": {\r\n            go: function () {\r\n                stack.push({state: \"ok\"});\r\n                container = [];\r\n                state = \"firstavalue\";\r\n            },\r\n            ovalue: function () {\r\n                stack.push({container: container, state: \"ocomma\", key: key});\r\n                container = [];\r\n                state = \"firstavalue\";\r\n            },\r\n            firstavalue: function () {\r\n                stack.push({container: container, state: \"acomma\"});\r\n                container = [];\r\n                state = \"firstavalue\";\r\n            },\r\n            avalue: function () {\r\n                stack.push({container: container, state: \"acomma\"});\r\n                container = [];\r\n                state = \"firstavalue\";\r\n            }\r\n        },\r\n        \"]\": {\r\n            firstavalue: function () {\r\n                var pop = stack.pop();\r\n                value = container;\r\n                container = pop.container;\r\n                key = pop.key;\r\n                state = pop.state;\r\n            },\r\n            acomma: function () {\r\n                var pop = stack.pop();\r\n                container.push(value);\r\n                value = container;\r\n                container = pop.container;\r\n                key = pop.key;\r\n                state = pop.state;\r\n            }\r\n        },\r\n        \":\": {\r\n            colon: function () {\r\n                if (Object.hasOwnProperty.call(container, key)) {\r\n                    throw new SyntaxError(\"Duplicate key '\" + key + \"\\\"\");\r\n                }\r\n                state = \"ovalue\";\r\n            }\r\n        },\r\n        \",\": {\r\n            ocomma: function () {\r\n                container[key] = value;\r\n                state = \"okey\";\r\n            },\r\n            acomma: function () {\r\n                container.push(value);\r\n                state = \"avalue\";\r\n            }\r\n        },\r\n        \"true\": {\r\n            go: function () {\r\n                value = true;\r\n                state = \"ok\";\r\n            },\r\n            ovalue: function () {\r\n                value = true;\r\n                state = \"ocomma\";\r\n            },\r\n            firstavalue: function () {\r\n                value = true;\r\n                state = \"acomma\";\r\n            },\r\n            avalue: function () {\r\n                value = true;\r\n                state = \"acomma\";\r\n            }\r\n        },\r\n        \"false\": {\r\n            go: function () {\r\n                value = false;\r\n                state = \"ok\";\r\n            },\r\n            ovalue: function () {\r\n                value = false;\r\n                state = \"ocomma\";\r\n            },\r\n            firstavalue: function () {\r\n                value = false;\r\n                state = \"acomma\";\r\n            },\r\n            avalue: function () {\r\n                value = false;\r\n                state = \"acomma\";\r\n            }\r\n        },\r\n        \"null\": {\r\n            go: function () {\r\n                value = null;\r\n                state = \"ok\";\r\n            },\r\n            ovalue: function () {\r\n                value = null;\r\n                state = \"ocomma\";\r\n            },\r\n            firstavalue: function () {\r\n                value = null;\r\n                state = \"acomma\";\r\n            },\r\n            avalue: function () {\r\n                value = null;\r\n                state = \"acomma\";\r\n            }\r\n        }\r\n    };\r\n\r\n    function debackslashify(text) {\r\n\r\n// Remove and replace any backslash escapement.\r\n\r\n        return text.replace(/\\\\(?:u(.{4})|([^u]))/g, function (ignore, b, c) {\r\n            return b\r\n                ? String.fromCharCode(parseInt(b, 16))\r\n                : escapes[c];\r\n        });\r\n    }\r\n\r\n    function parse(source, reviver) {\r\n\r\n// A regular expression is used to extract tokens from the JSON text.\r\n// The extraction process is cautious.\r\n\r\n        var result;\r\n        var tx = /^[\\u0020\\t\\n\\r]*(?:([,:\\[\\]{}]|true|false|null)|(-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)|\"((?:[^\\r\\n\\t\\\\\\\"]|\\\\(?:[\"\\\\\\/trnfb]|u[0-9a-fA-F]{4}))*)\")/;\r\n\r\n// Set the starting state.\r\n\r\n        state = \"go\";\r\n\r\n// The stack records the container, key, and state for each object or array\r\n// that contains another object or array while processing nested structures.\r\n\r\n        stack = [];\r\n\r\n// If any error occurs, we will catch it and ultimately throw a syntax error.\r\n\r\n        try {\r\n\r\n// For each token...\r\n\r\n            while (true) {\r\n                result = tx.exec(source);\r\n                if (!result) {\r\n                    break;\r\n                }\r\n\r\n// result is the result array from matching the tokenizing regular expression.\r\n//  result[0] contains everything that matched, including any initial whitespace.\r\n//  result[1] contains any punctuation that was matched, or true, false, or null.\r\n//  result[2] contains a matched number, still in string form.\r\n//  result[3] contains a matched string, without quotes but with escapement.\r\n\r\n                if (result[1]) {\r\n\r\n// Token: Execute the action for this state and token.\r\n\r\n                    action[result[1]][state]();\r\n\r\n                } else if (result[2]) {\r\n\r\n// Number token: Convert the number string into a number value and execute\r\n// the action for this state and number.\r\n\r\n                    value = +result[2];\r\n                    number[state]();\r\n                } else {\r\n\r\n// String token: Replace the escapement sequences and execute the action for\r\n// this state and string.\r\n\r\n                    value = debackslashify(result[3]);\r\n                    string[state]();\r\n                }\r\n\r\n// Remove the token from the string. The loop will continue as long as there\r\n// are tokens. This is a slow process, but it allows the use of ^ matching,\r\n// which assures that no illegal tokens slip through.\r\n\r\n                source = source.slice(result[0].length);\r\n            }\r\n\r\n// If we find a state/token combination that is illegal, then the action will\r\n// cause an error. We handle the error by simply changing the state.\r\n\r\n        } catch (e) {\r\n            state = e;\r\n        }\r\n\r\n// The parsing is finished. If we are not in the final \"ok\" state, or if the\r\n// remaining source contains anything except whitespace, then we did not have\r\n//a well-formed JSON text.\r\n\r\n        if (state !== \"ok\" || (/[^\\u0020\\t\\n\\r]/.test(source))) {\r\n            throw (state instanceof SyntaxError)\r\n                ? state\r\n                : new SyntaxError(\"JSON\");\r\n        }\r\n\r\n// If there is a reviver function, we recursively walk the new structure,\r\n// passing each name/value pair to the reviver function for possible\r\n// transformation, starting with a temporary root object that holds the current\r\n// value in an empty key. If there is not a reviver function, we simply return\r\n// that value.\r\n\r\n        return (typeof reviver === \"function\")\r\n            ? (function walk(holder, key) {\r\n                var k;\r\n                var v;\r\n                var val = holder[key];\r\n                if (val && typeof val === \"object\") {\r\n                    for (k in value) {\r\n                        if (Object.prototype.hasOwnProperty.call(val, k)) {\r\n                            v = walk(val, k);\r\n                            if (v !== undefined) {\r\n                                val[k] = v;\r\n                            } else {\r\n                                delete val[k];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return reviver.call(holder, key, val);\r\n            }({\"\": value}, \"\"))\r\n            : value;\r\n    }\r\n    \r\n    return json.parse = parse;\r\n\r\n});"]}